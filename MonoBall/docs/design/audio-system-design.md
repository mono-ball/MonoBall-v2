# Audio System Design

## Overview

This document describes the architecture for MonoBall's audio system, designed to be event-driven, ECS-based, mod-extensible, and cross-platform (Windows, Mac, Linux).

## Design Principles

1. **Event-Driven**: All audio operations triggered via events, enabling decoupled systems
2. **ECS-Based**: Audio state managed through components and systems
3. **Mod-Extensible**: Audio definitions loaded from mods, supports custom audio types
4. **Cross-Platform**: Uses PortAudio + NVorbis for cross-platform audio (Windows/Mac/Linux)
5. **Fail-Fast**: No fallback code, clear exceptions for missing dependencies
6. **No Backward Compatibility**: Clean API, refactor freely

## Architecture Layers

### 1. Core Audio Services (`Audio/Services/`)

#### `IAudioEngine` / `AudioEngine`
Low-level audio playback abstraction. Uses PortAudio for cross-platform audio output and NVorbis for OGG Vorbis file reading.

**Namespace:** `MonoBall.Core.Audio`

**Dependencies:**
- **PortAudioSharp**: Cross-platform audio output (Windows/Mac/Linux)
- **NVorbis**: OGG Vorbis file reading with streaming support
- **Custom AudioMixer**: Mixes multiple audio streams (for crossfading)
- **IModManager**: For resolving mod directories (following `SpriteLoaderService` pattern)

**Responsibilities:**
- Sound effect playback (fire-and-forget)
- Sound effect instance management (looping, volume, pitch, pan)
- Music playback with streaming support
- Volume management (master, music, SFX)
- Platform abstraction via PortAudio

**Key Methods:**
```csharp
namespace MonoBall.Core.Audio
{
    /// <summary>
    /// Interface for low-level audio playback abstraction.
    /// </summary>
    public interface IAudioEngine
    {
        // Sound effects
        ISoundEffectInstance? PlaySound(string audioId, float volume, float pitch, float pan);
        ISoundEffectInstance? PlayLoopingSound(string audioId, float volume);
        void StopSound(ISoundEffectInstance instance);

        // Music
        void PlayMusic(string audioId, bool loop, float fadeInDuration);
        void StopMusic(float fadeOutDuration);
        void PauseMusic();
        void ResumeMusic();
        void CrossfadeMusic(string newAudioId, float crossfadeDuration, bool loop);

        // Volume
        float MasterVolume { get; set; }
        float MusicVolume { get; set; }
        float SoundEffectVolume { get; set; }
        
        // Update (called from game loop)
        void Update(float deltaTime);
    }
}
```

#### `IAudioContentLoader` / `AudioContentLoader`
Loads audio assets from mod content directories. Only handles file loading, not definition access.

**Namespace:** `MonoBall.Core.Audio`

**Responsibilities:**
- Resolve audio file paths using `IModManager` (following `SpriteLoaderService` pattern)
- Create `VorbisReader` instances for streaming OGG files
- Cache management for track metadata

**Key Methods:**
```csharp
namespace MonoBall.Core.Audio
{
    /// <summary>
    /// Interface for loading audio assets from mod content directories.
    /// </summary>
    public interface IAudioContentLoader
    {
        /// <summary>
        /// Creates a VorbisReader for the specified audio definition.
        /// </summary>
        /// <param name="audioId">The audio definition ID.</param>
        /// <param name="definition">The audio definition (obtained from DefinitionRegistry).</param>
        /// <param name="modManifest">The mod manifest (obtained from IModManager).</param>
        /// <returns>The VorbisReader, or null if file not found.</returns>
        VorbisReader? CreateVorbisReader(string audioId, AudioDefinition definition, ModManifest modManifest);

        /// <summary>
        /// Unloads cached metadata for the specified audio.
        /// </summary>
        void Unload(string audioId);
    }
}
```

**Resource Loading Pattern:**
Follows the same pattern as `SpriteLoaderService` and `TilesetLoaderService`:
1. Systems call `_registry.GetById<AudioDefinition>(audioId)` to get definition
2. Systems call `_modManager.GetModManifestByDefinitionId(audioId)` to get mod manifest
3. Systems call `_contentLoader.CreateVorbisReader(audioId, definition, modManifest)` to load file
4. Returns `null` if file not found (logs warning), throws exceptions only for invalid state

### 2. Audio Definitions (`Audio/`)

Audio definitions are already loaded from mod JSON files via the `DefinitionRegistry`. The existing format matches the structure generated by porycon2.

**Definition Type:** `DefinitionType = "audio"`

**Namespace:** `MonoBall.Core.Audio`

#### `AudioDefinition` Class

```csharp
namespace MonoBall.Core.Audio
{
    /// <summary>
    /// Represents an audio definition loaded from mod JSON files.
    /// </summary>
    public class AudioDefinition
    {
        /// <summary>
        /// The unique identifier of the audio definition (unified ID format).
        /// </summary>
        public string Id { get; set; } = string.Empty;

        /// <summary>
        /// Human-readable display name.
        /// </summary>
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Path to audio file relative to mod directory.
        /// </summary>
        public string AudioPath { get; set; } = string.Empty;

        /// <summary>
        /// Default volume (0.0 - 1.0).
        /// </summary>
        public float Volume { get; set; } = 1.0f;

        /// <summary>
        /// Whether the track should loop.
        /// </summary>
        public bool Loop { get; set; } = true;

        /// <summary>
        /// Fade-in duration in seconds.
        /// </summary>
        public float FadeIn { get; set; }

        /// <summary>
        /// Fade-out duration in seconds.
        /// </summary>
        public float FadeOut { get; set; }

        /// <summary>
        /// Loop start position in samples (at 44100 Hz, optional).
        /// </summary>
        public int? LoopStartSamples { get; set; }

        /// <summary>
        /// Loop length in samples (optional).
        /// </summary>
        public int? LoopLengthSamples { get; set; }

        /// <summary>
        /// Loop start position in seconds (optional).
        /// </summary>
        public float? LoopStartSec { get; set; }

        /// <summary>
        /// Loop end position in seconds (optional).
        /// </summary>
        public float? LoopEndSec { get; set; }
    }
}
```

**Definition Structure:**
```json
{
  "id": "base:audio:music/towns/mus_littleroot",
  "name": "Littleroot",
  "audioPath": "Audio/Music/Towns/mus_littleroot.ogg",
  "volume": 0.787,
  "loop": true,
  "fadeIn": 0.5,
  "fadeOut": 0.5,
  "loopStartSamples": 36749,
  "loopLengthSamples": 2351997,
  "loopStartSec": 0.833,
  "loopEndSec": 54.167
}
```

**Field Descriptions:**
- `id`: Unified ID format (`base:audio:category/subcategory/track_id`)
- `name`: Human-readable display name
- `audioPath`: Path to audio file relative to mod directory
- `volume`: Default volume (0.0 - 1.0)
- `loop`: Whether the track should loop
- `fadeIn`: Fade-in duration in seconds
- `fadeOut`: Fade-out duration in seconds
- `loopStartSamples`: Loop start position in samples (at 44100 Hz, optional)
- `loopLengthSamples`: Loop length in samples (optional)
- `loopStartSec`: Loop start position in seconds (optional)
- `loopEndSec`: Loop end position in seconds (optional)

**Audio Categories (from ID):**
The audio category is determined from the ID format `base:audio:category/subcategory/track_id`:
- `music/*`: Background music (streamed, supports looping)
- `sfx/*`: Sound effects (loaded into memory)
  - `sfx/ui`: UI sound effects
  - `sfx/battle`: Battle sound effects
  - `sfx/environment`: Environmental sound effects

**Note:** Audio definitions are already loaded by `ModLoader` into `DefinitionRegistry` with `DefinitionType = "audio"`. Systems access definitions directly using `_registry.GetById<AudioDefinition>(audioId)` (following `MapLoaderSystem` pattern).

### 3. ECS Components (`ECS/Components/Audio/`)

#### `MusicComponent`
Component attached to map entities to specify background music.

**Namespace:** `MonoBall.Core.ECS.Components.Audio`

```csharp
namespace MonoBall.Core.ECS.Components.Audio
{
    /// <summary>
    /// Component attached to map entities to specify background music.
    /// </summary>
    public struct MusicComponent
    {
        /// <summary>
        /// The audio definition ID for the music track.
        /// </summary>
        public string AudioId { get; set; }
        
        /// <summary>
        /// Whether to fade in when transitioning to this map.
        /// </summary>
        public bool FadeInOnTransition { get; set; }
        
        /// <summary>
        /// Custom fade duration (0 = use definition default).
        /// </summary>
        public float FadeDuration { get; set; }
    }
}
```

#### `SoundEffectRequestComponent`
Component for requesting sound effect playback (processed and removed).

**Namespace:** `MonoBall.Core.ECS.Components.Audio`

```csharp
namespace MonoBall.Core.ECS.Components.Audio
{
    /// <summary>
    /// Component for requesting sound effect playback.
    /// System processes this component and removes it after playback starts.
    /// </summary>
    public struct SoundEffectRequestComponent
    {
        /// <summary>
        /// The audio definition ID for the sound effect.
        /// </summary>
        public string AudioId { get; set; }
        
        /// <summary>
        /// Volume override (0-1, or -1 to use definition default).
        /// </summary>
        public float Volume { get; set; }
        
        /// <summary>
        /// Pitch adjustment (-1 to 1).
        /// </summary>
        public float Pitch { get; set; }
        
        /// <summary>
        /// Pan adjustment (-1 left to 1 right).
        /// </summary>
        public float Pan { get; set; }
    }
}
```

#### `AmbientSoundComponent`
Component for entities that emit ambient/looping sounds. Contains only data; system manages instances.

**Namespace:** `MonoBall.Core.ECS.Components.Audio`

```csharp
namespace MonoBall.Core.ECS.Components.Audio
{
    /// <summary>
    /// Component for entities that emit ambient/looping sounds.
    /// The system manages sound instances separately (components are pure data).
    /// </summary>
    public struct AmbientSoundComponent
    {
        /// <summary>
        /// The audio definition ID for the ambient sound.
        /// </summary>
        public string AudioId { get; set; }
        
        /// <summary>
        /// Volume override (0-1, or -1 to use definition default).
        /// </summary>
        public float Volume { get; set; }
        
        /// <summary>
        /// Pitch adjustment (-1 to 1).
        /// </summary>
        public float Pitch { get; set; }
        
        /// <summary>
        /// Pan adjustment (-1 left to 1 right).
        /// </summary>
        public float Pan { get; set; }
    }
}
```

**Note:** The `AmbientSoundSystem` manages sound instances in a dictionary (`Dictionary<Entity, ISoundEffectInstance>`) since components cannot store managed resources.

### 4. ECS Systems (`ECS/Systems/Audio/`)

#### `MapMusicSystem`
Manages background music based on map transitions.

**Namespace:** `MonoBall.Core.ECS.Systems.Audio`

**Priority:** `SystemPriority.Audio` (e.g., 600)

**Responsibilities:**
- Subscribe to `MapTransitionEvent` and `GameEnteredEvent`
- Query maps for `MusicComponent` using cached `QueryDescription`
- Request music playback via `PlayMusicEvent`
- Handle music transitions (fade/crossfade)

**Implementation:**
```csharp
namespace MonoBall.Core.ECS.Systems.Audio
{
    /// <summary>
    /// System that manages map background music based on map transitions.
    /// </summary>
    public class MapMusicSystem : BaseSystem<World, float>, IPrioritizedSystem, IDisposable
    {
        private readonly DefinitionRegistry _registry;
        private readonly QueryDescription _mapMusicQuery;
        private readonly ILogger _logger;
        private string? _currentMapMusicId;
        private bool _disposed = false;
        
        /// <summary>
        /// Gets the execution priority for this system.
        /// </summary>
        public int Priority => SystemPriority.Audio;
        
        /// <summary>
        /// Initializes a new instance of the MapMusicSystem.
        /// </summary>
        /// <param name="world">The ECS world.</param>
        /// <param name="registry">The definition registry.</param>
        /// <param name="logger">The logger for logging operations.</param>
        public MapMusicSystem(World world, DefinitionRegistry registry, ILogger logger) : base(world)
        {
            _registry = registry ?? throw new ArgumentNullException(nameof(registry));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            
            // Cache QueryDescription in constructor (required by .cursorrules)
            _mapMusicQuery = new QueryDescription()
                .WithAll<MapComponent, MusicComponent>();
            
            EventBus.Subscribe<MapTransitionEvent>(OnMapTransition);
            EventBus.Subscribe<GameEnteredEvent>(OnGameEntered);
        }
        
        private void OnMapTransition(ref MapTransitionEvent evt)
        {
            if (string.IsNullOrEmpty(evt.TargetMapId))
            {
                return;
            }
            
            // Query for target map's music component
            string? musicId = null;
            float fadeDuration = 0f;
            
            World.Query(in _mapMusicQuery, (ref MapComponent map, ref MusicComponent music) =>
            {
                if (map.MapId == evt.TargetMapId)
                {
                    musicId = music.AudioId;
                    fadeDuration = music.FadeDuration > 0 ? music.FadeDuration : 0f;
                }
            });
            
            if (!string.IsNullOrEmpty(musicId) && musicId != _currentMapMusicId)
            {
                var playMusicEvent = new PlayMusicEvent
                {
                    AudioId = musicId,
                    Loop = true,
                    FadeInDuration = fadeDuration,
                    Crossfade = fadeDuration > 0
                };
                EventBus.Send(ref playMusicEvent);
                _currentMapMusicId = musicId;
            }
        }
        
        private void OnGameEntered(ref GameEnteredEvent evt)
        {
            if (string.IsNullOrEmpty(evt.InitialMapId))
            {
                return;
            }
            
            // Query for initial map's music component
            string? musicId = null;
            float fadeDuration = 0f;
            
            World.Query(in _mapMusicQuery, (ref MapComponent map, ref MusicComponent music) =>
            {
                if (map.MapId == evt.InitialMapId)
                {
                    musicId = music.AudioId;
                    fadeDuration = music.FadeDuration > 0 ? music.FadeDuration : 0f;
                }
            });
            
            if (!string.IsNullOrEmpty(musicId))
            {
                var playMusicEvent = new PlayMusicEvent
                {
                    AudioId = musicId,
                    Loop = true,
                    FadeInDuration = fadeDuration,
                    Crossfade = false
                };
                EventBus.Send(ref playMusicEvent);
                _currentMapMusicId = musicId;
            }
        }
        
        /// <summary>
        /// Disposes the system and unsubscribes from events.
        /// </summary>
        public new void Dispose()
        {
            if (!_disposed)
            {
                EventBus.Unsubscribe<MapTransitionEvent>(OnMapTransition);
                EventBus.Unsubscribe<GameEnteredEvent>(OnGameEntered);
                _disposed = true;
            }
        }
    }
}
```

#### `SoundEffectSystem`
Processes sound effect requests and plays them.

**Namespace:** `MonoBall.Core.ECS.Systems.Audio`

**Priority:** `SystemPriority.Audio + 10` (e.g., 610)

**Responsibilities:**
- Query for entities with `SoundEffectRequestComponent` using cached `QueryDescription`
- Get audio definitions from `DefinitionRegistry`
- Load and play sound effects via `IAudioEngine`
- Remove `SoundEffectRequestComponent` after playback starts

**Implementation:**
```csharp
namespace MonoBall.Core.ECS.Systems.Audio
{
    /// <summary>
    /// System that processes sound effect requests and plays them.
    /// </summary>
    public class SoundEffectSystem : BaseSystem<World, float>, IPrioritizedSystem
    {
        private readonly DefinitionRegistry _registry;
        private readonly IAudioEngine _audioEngine;
        private readonly QueryDescription _soundEffectQuery;
        private readonly ILogger _logger;
        
        /// <summary>
        /// Gets the execution priority for this system.
        /// </summary>
        public int Priority => SystemPriority.Audio + 10;
        
        /// <summary>
        /// Initializes a new instance of the SoundEffectSystem.
        /// </summary>
        /// <param name="world">The ECS world.</param>
        /// <param name="registry">The definition registry.</param>
        /// <param name="audioEngine">The audio engine for playing sounds.</param>
        /// <param name="logger">The logger for logging operations.</param>
        public SoundEffectSystem(
            World world,
            DefinitionRegistry registry,
            IAudioEngine audioEngine,
            ILogger logger
        ) : base(world)
        {
            _registry = registry ?? throw new ArgumentNullException(nameof(registry));
            _audioEngine = audioEngine ?? throw new ArgumentNullException(nameof(audioEngine));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            
            // Cache QueryDescription in constructor (required by .cursorrules)
            _soundEffectQuery = new QueryDescription()
                .WithAll<SoundEffectRequestComponent>();
        }
        
        public override void Update(in float deltaTime)
        {
            World.Query(in _soundEffectQuery, (Entity entity, ref SoundEffectRequestComponent request) =>
            {
                // Get definition from registry
                var definition = _registry.GetById<AudioDefinition>(request.AudioId);
                if (definition == null)
                {
                    _logger.Warning("Audio definition not found: {AudioId}", request.AudioId);
                    World.Remove<SoundEffectRequestComponent>(entity);
                    return;
                }
                
                // Determine volume (use request override or definition default)
                float volume = request.Volume >= 0 ? request.Volume : definition.Volume;
                
                // Play sound effect
                _audioEngine.PlaySound(
                    request.AudioId,
                    volume,
                    request.Pitch,
                    request.Pan
                );
                
                // Remove component after processing
                World.Remove<SoundEffectRequestComponent>(entity);
            });
        }
    }
}
```

#### `AmbientSoundSystem`
Manages looping ambient sounds attached to entities.

**Namespace:** `MonoBall.Core.ECS.Systems.Audio`

**Priority:** `SystemPriority.Audio + 20` (e.g., 620)

**Responsibilities:**
- Query for entities with `AmbientSoundComponent` using cached `QueryDescription`
- Start/stop ambient sounds based on entity state
- Manage sound instances in a dictionary (components cannot store managed resources)
- Update 3D positioning (if needed)
- Clean up stopped instances

**Implementation:**
```csharp
namespace MonoBall.Core.ECS.Systems.Audio
{
    /// <summary>
    /// System that manages looping ambient sounds attached to entities.
    /// </summary>
    public class AmbientSoundSystem : BaseSystem<World, float>, IPrioritizedSystem, IDisposable
    {
        private readonly DefinitionRegistry _registry;
        private readonly IModManager _modManager;
        private readonly IAudioEngine _audioEngine;
        private readonly IAudioContentLoader _contentLoader;
        private readonly QueryDescription _ambientSoundQuery;
        private readonly Dictionary<Entity, ISoundEffectInstance> _ambientInstances = new();
        private readonly ILogger _logger;
        private bool _disposed = false;
        
        /// <summary>
        /// Gets the execution priority for this system.
        /// </summary>
        public int Priority => SystemPriority.Audio + 20;
        
        public AmbientSoundSystem(
            World world,
            DefinitionRegistry registry,
            IModManager modManager,
            IAudioEngine audioEngine,
            IAudioContentLoader contentLoader,
            ILogger logger
        ) : base(world)
        {
            _registry = registry ?? throw new ArgumentNullException(nameof(registry));
            _modManager = modManager ?? throw new ArgumentNullException(nameof(modManager));
            _audioEngine = audioEngine ?? throw new ArgumentNullException(nameof(audioEngine));
            _contentLoader = contentLoader ?? throw new ArgumentNullException(nameof(contentLoader));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            
            // Cache QueryDescription in constructor (required by .cursorrules)
            _ambientSoundQuery = new QueryDescription()
                .WithAll<AmbientSoundComponent>();
        }
        
        public override void Update(in float deltaTime)
        {
            // Query for entities with ambient sound component
            World.Query(in _ambientSoundQuery, (Entity entity, ref AmbientSoundComponent ambient) =>
            {
                // Check if instance exists
                if (!_ambientInstances.ContainsKey(entity))
                {
                    // Start new ambient sound
                    var definition = _registry.GetById<AudioDefinition>(ambient.AudioId);
                    if (definition == null)
                    {
                        _logger.Warning("Audio definition not found: {AudioId}", ambient.AudioId);
                        return;
                    }
                    
                    float volume = ambient.Volume >= 0 ? ambient.Volume : definition.Volume;
                    var instance = _audioEngine.PlayLoopingSound(ambient.AudioId, volume);
                    if (instance != null)
                    {
                        _ambientInstances[entity] = instance;
                    }
                }
                else
                {
                    // Update existing instance volume if changed
                    var instance = _ambientInstances[entity];
                    if (instance != null && !instance.IsPlaying)
                    {
                        // Instance stopped, remove it
                        _ambientInstances.Remove(entity);
                    }
                }
            });
            
            // Clean up instances for entities that no longer have component
            var entitiesToRemove = _ambientInstances.Keys
                .Where(e => !World.Has<AmbientSoundComponent>(e))
                .ToList();
            
            foreach (var entity in entitiesToRemove)
            {
                _ambientInstances[entity]?.Stop();
                _ambientInstances.Remove(entity);
            }
        }
        
        public new void Dispose()
        {
            if (!_disposed)
            {
                foreach (var instance in _ambientInstances.Values)
                {
                    instance?.Stop();
                }
                _ambientInstances.Clear();
                _disposed = true;
            }
        }
    }
}
```

#### `MusicPlaybackSystem`
Handles music playback events and manages music state.

**Namespace:** `MonoBall.Core.ECS.Systems.Audio`

**Priority:** `SystemPriority.Audio + 5` (e.g., 605)

**Responsibilities:**
- Subscribe to `PlayMusicEvent` and `StopMusicEvent`
- Load and play music via `IAudioEngine`
- Handle crossfading and fading

**Implementation:**
```csharp
namespace MonoBall.Core.ECS.Systems.Audio
{
    /// <summary>
    /// System that handles music playback events and manages music state.
    /// </summary>
    public class MusicPlaybackSystem : BaseSystem<World, float>, IPrioritizedSystem, IDisposable
    {
        private readonly DefinitionRegistry _registry;
        private readonly IModManager _modManager;
        private readonly IAudioEngine _audioEngine;
        private readonly IAudioContentLoader _contentLoader;
        private readonly ILogger _logger;
        private bool _disposed = false;
        
        /// <summary>
        /// Gets the execution priority for this system.
        /// </summary>
        public int Priority => SystemPriority.Audio + 5;
        
        public MusicPlaybackSystem(
            World world,
            DefinitionRegistry registry,
            IModManager modManager,
            IAudioEngine audioEngine,
            IAudioContentLoader contentLoader,
            ILogger logger
        ) : base(world)
        {
            _registry = registry ?? throw new ArgumentNullException(nameof(registry));
            _modManager = modManager ?? throw new ArgumentNullException(nameof(modManager));
            _audioEngine = audioEngine ?? throw new ArgumentNullException(nameof(audioEngine));
            _contentLoader = contentLoader ?? throw new ArgumentNullException(nameof(contentLoader));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            
            EventBus.Subscribe<PlayMusicEvent>(OnPlayMusic);
            EventBus.Subscribe<StopMusicEvent>(OnStopMusic);
        }
        
        private void OnPlayMusic(ref PlayMusicEvent evt)
        {
            if (string.IsNullOrEmpty(evt.AudioId))
            {
                _logger.Warning("PlayMusicEvent received with empty AudioId");
                return;
            }
            
            // Get definition
            var definition = _registry.GetById<AudioDefinition>(evt.AudioId);
            if (definition == null)
            {
                _logger.Warning("Audio definition not found: {AudioId}", evt.AudioId);
                return;
            }
            
            // Determine loop and fade settings
            bool loop = evt.Loop || definition.Loop;
            float fadeIn = evt.FadeInDuration > 0 ? evt.FadeInDuration : definition.FadeIn;
            
            if (evt.Crossfade)
            {
                _audioEngine.CrossfadeMusic(evt.AudioId, evt.CrossfadeDuration, loop);
            }
            else
            {
                _audioEngine.PlayMusic(evt.AudioId, loop, fadeIn);
            }
        }
        
        private void OnStopMusic(ref StopMusicEvent evt)
        {
            _audioEngine.StopMusic(evt.FadeOutDuration);
        }
        
        public new void Dispose()
        {
            if (!_disposed)
            {
                EventBus.Unsubscribe<PlayMusicEvent>(OnPlayMusic);
                EventBus.Unsubscribe<StopMusicEvent>(OnStopMusic);
                _disposed = true;
            }
        }
    }
}
```

#### `AudioVolumeSystem`
Manages audio volume settings and applies them to the audio engine.

**Namespace:** `MonoBall.Core.ECS.Systems.Audio`

**Priority:** `SystemPriority.Audio + 30` (e.g., 630)

**Responsibilities:**
- Subscribe to volume change events
- Apply volume settings to `IAudioEngine`
- Persist volume settings (optional)

**Implementation:**
```csharp
namespace MonoBall.Core.ECS.Systems.Audio
{
    /// <summary>
    /// System that manages audio volume settings and applies them to the audio engine.
    /// </summary>
    public class AudioVolumeSystem : BaseSystem<World, float>, IPrioritizedSystem, IDisposable
    {
        private readonly IAudioEngine _audioEngine;
        private readonly ILogger _logger;
        private bool _disposed = false;
        
        /// <summary>
        /// Gets the execution priority for this system.
        /// </summary>
        public int Priority => SystemPriority.Audio + 30;
        
        /// <summary>
        /// Initializes a new instance of the AudioVolumeSystem.
        /// </summary>
        /// <param name="world">The ECS world.</param>
        /// <param name="audioEngine">The audio engine to apply volume settings to.</param>
        /// <param name="logger">The logger for logging operations.</param>
        public AudioVolumeSystem(World world, IAudioEngine audioEngine, ILogger logger) : base(world)
        {
            _audioEngine = audioEngine ?? throw new ArgumentNullException(nameof(audioEngine));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            
            EventBus.Subscribe<SetMasterVolumeEvent>(OnMasterVolumeChanged);
            EventBus.Subscribe<SetMusicVolumeEvent>(OnMusicVolumeChanged);
            EventBus.Subscribe<SetSoundEffectVolumeEvent>(OnSoundEffectVolumeChanged);
        }
        
        private void OnMasterVolumeChanged(ref SetMasterVolumeEvent evt)
        {
            _audioEngine.MasterVolume = evt.Volume;
            _logger.Debug("Master volume set to {Volume}", evt.Volume);
        }
        
        private void OnMusicVolumeChanged(ref SetMusicVolumeEvent evt)
        {
            _audioEngine.MusicVolume = evt.Volume;
            _logger.Debug("Music volume set to {Volume}", evt.Volume);
        }
        
        private void OnSoundEffectVolumeChanged(ref SetSoundEffectVolumeEvent evt)
        {
            _audioEngine.SoundEffectVolume = evt.Volume;
            _logger.Debug("Sound effect volume set to {Volume}", evt.Volume);
        }
        
        /// <summary>
        /// Disposes the system and unsubscribes from events.
        /// </summary>
        public new void Dispose()
        {
            if (!_disposed)
            {
                EventBus.Unsubscribe<SetMasterVolumeEvent>(OnMasterVolumeChanged);
                EventBus.Unsubscribe<SetMusicVolumeEvent>(OnMusicVolumeChanged);
                EventBus.Unsubscribe<SetSoundEffectVolumeEvent>(OnSoundEffectVolumeChanged);
                _disposed = true;
            }
        }
    }
}
```

### 5. Events (`ECS/Events/Audio/`)

All events are structs (value types) following the existing event pattern.

**Namespace:** `MonoBall.Core.ECS.Events.Audio`

#### `PlayMusicEvent`
Request to play background music.

```csharp
namespace MonoBall.Core.ECS.Events.Audio
{
    /// <summary>
    /// Event fired to request playing background music.
    /// </summary>
    public struct PlayMusicEvent
    {
        /// <summary>
        /// The audio definition ID for the music track.
        /// </summary>
        public string AudioId { get; set; }
        
        /// <summary>
        /// Whether the music should loop.
        /// </summary>
        public bool Loop { get; set; }
        
        /// <summary>
        /// Fade-in duration in seconds (0 = instant).
        /// </summary>
        public float FadeInDuration { get; set; }
        
        /// <summary>
        /// Whether to crossfade with current music (if playing).
        /// </summary>
        public bool Crossfade { get; set; }
        
        /// <summary>
        /// Crossfade duration in seconds (only used if Crossfade is true).
        /// </summary>
        public float CrossfadeDuration { get; set; }
    }
}
```

#### `StopMusicEvent`
Request to stop background music.

```csharp
namespace MonoBall.Core.ECS.Events.Audio
{
    /// <summary>
    /// Event fired to request stopping background music.
    /// </summary>
    public struct StopMusicEvent
    {
        /// <summary>
        /// Fade-out duration in seconds (0 = instant).
        /// </summary>
        public float FadeOutDuration { get; set; }
    }
}
```

#### `PlaySoundEffectEvent`
Request to play a sound effect.

```csharp
namespace MonoBall.Core.ECS.Events.Audio
{
    /// <summary>
    /// Event fired to request playing a sound effect.
    /// </summary>
    public struct PlaySoundEffectEvent
    {
        /// <summary>
        /// The audio definition ID for the sound effect.
        /// </summary>
        public string AudioId { get; set; }
        
        /// <summary>
        /// Volume override (0-1, or -1 to use definition default).
        /// </summary>
        public float Volume { get; set; }
        
        /// <summary>
        /// Pitch adjustment (-1 to 1).
        /// </summary>
        public float Pitch { get; set; }
        
        /// <summary>
        /// Pan adjustment (-1 left to 1 right).
        /// </summary>
        public float Pan { get; set; }
    }
}
```

#### `SetMasterVolumeEvent`
Request to change master volume.

```csharp
namespace MonoBall.Core.ECS.Events.Audio
{
    /// <summary>
    /// Event fired to change master volume.
    /// </summary>
    public struct SetMasterVolumeEvent
    {
        /// <summary>
        /// Master volume (0-1).
        /// </summary>
        public float Volume { get; set; }
    }
}
```

#### `SetMusicVolumeEvent`
Request to change music volume.

```csharp
namespace MonoBall.Core.ECS.Events.Audio
{
    /// <summary>
    /// Event fired to change music volume.
    /// </summary>
    public struct SetMusicVolumeEvent
    {
        /// <summary>
        /// Music volume (0-1).
        /// </summary>
        public float Volume { get; set; }
    }
}
```

#### `SetSoundEffectVolumeEvent`
Request to change sound effect volume.

```csharp
namespace MonoBall.Core.ECS.Events.Audio
{
    /// <summary>
    /// Event fired to change sound effect volume.
    /// </summary>
    public struct SetSoundEffectVolumeEvent
    {
        /// <summary>
        /// Sound effect volume (0-1).
        /// </summary>
        public float Volume { get; set; }
    }
}
```

### 6. Music Playback Implementation

#### OGG Vorbis Support

Uses **NVorbis** library for OGG Vorbis file reading with streaming support:

1. **VorbisReader**: Custom wrapper around `NVorbis.VorbisReader` that provides:
   - Streaming audio data (reads samples on-demand)
   - Thread-safe read operations
   - Seek support (by sample or time)
   - Loop point support via definition metadata

2. **Loop Points**: Stored in audio definition JSON:
   - `loopStartSamples`: Loop start position in samples (44100 Hz)
   - `loopLengthSamples`: Loop length in samples
   - `loopStartSec`: Loop start position in seconds
   - `loopEndSec`: Loop end position in seconds

3. **Streaming Playback**: 
   - `VorbisReader` streams samples on-demand (no full-file loading)
   - Memory efficient (~64KB per active stream vs ~32MB cached)
   - Supports seamless looping with custom loop points

**Implementation:**
- `VorbisReader` wraps `NVorbis.VorbisReader` for thread-safe access
- `LoopingSampleProvider` handles loop point logic
- `VolumeProvider` applies volume scaling
- `ResampleProvider` handles sample rate conversion if needed

#### Crossfading

Implement crossfading using **AudioMixer**:

1. **AudioMixer**: Custom mixer that combines multiple audio streams
   - Thread-safe source addition/removal
   - Mixes multiple `ISampleProvider` sources
   - Supports simultaneous playback of multiple streams

2. **Crossfade Process**:
   - Add new track to mixer at volume 0
   - Fade out old track while fading in new track
   - Remove old track when fade completes
   - Both tracks play simultaneously during crossfade

3. **PortAudio Output**:
   - Single `PortAudioOutput` instance reads from `AudioMixer`
   - Mixer combines all active sources
   - PortAudio handles platform-specific audio output

**Benefits:**
- True crossfading (no gaps between tracks)
- Memory efficient (streaming, not cached)
- Cross-platform (PortAudio handles platform differences)

### 7. System Registration

Register audio systems in `SystemManager.Initialize()` following the existing pattern:

```csharp
// Create audio services (similar to sprite/tileset loaders)
// Note: AudioEngine may need additional dependencies (PortAudio initialization, etc.)
// This will be determined during implementation
_audioEngine = new AudioEngine(_modManager, LoggerFactory.CreateLogger<AudioEngine>());
_audioContentLoader = new AudioContentLoader(_modManager, LoggerFactory.CreateLogger<AudioContentLoader>());

// Create audio systems (after rendering systems, before scene systems)
_mapMusicSystem = new MapMusicSystem(
    _world,
    _modManager.Registry,  // ✅ Direct registry access
    LoggerFactory.CreateLogger<MapMusicSystem>()
);
RegisterUpdateSystem(_mapMusicSystem);

_musicPlaybackSystem = new MusicPlaybackSystem(
    _world,
    _modManager.Registry,  // ✅ Direct registry access
    _modManager,  // ✅ For path resolution
    _audioEngine,
    _audioContentLoader,
    LoggerFactory.CreateLogger<MusicPlaybackSystem>()
);
RegisterUpdateSystem(_musicPlaybackSystem);

_soundEffectSystem = new SoundEffectSystem(
    _world,
    _modManager.Registry,  // ✅ Direct registry access
    _audioEngine,
    LoggerFactory.CreateLogger<SoundEffectSystem>()
);
RegisterUpdateSystem(_soundEffectSystem);

_ambientSoundSystem = new AmbientSoundSystem(
    _world,
    _modManager.Registry,  // ✅ Direct registry access
    _modManager,  // ✅ For path resolution
    _audioEngine,
    _audioContentLoader,
    LoggerFactory.CreateLogger<AmbientSoundSystem>()
);
RegisterUpdateSystem(_ambientSoundSystem);

_audioVolumeSystem = new AudioVolumeSystem(
    _world,
    _audioEngine,
    LoggerFactory.CreateLogger<AudioVolumeSystem>()
);
RegisterUpdateSystem(_audioVolumeSystem);
```

**Note:** Add audio priority constants to `SystemPriority.cs`:
```csharp
// Audio systems
public const int Audio = 600;
```

### 8. Mod Integration

#### Audio Definition Format

Audio definitions already exist in `Mods/[ModName]/Definitions/Audio/` and follow this format:

```json
{
  "id": "base:audio:music/towns/mus_littleroot",
  "name": "Littleroot",
  "audioPath": "Audio/Music/Towns/mus_littleroot.ogg",
  "volume": 0.787,
  "loop": true,
  "fadeIn": 0.5,
  "fadeOut": 0.5,
  "loopStartSamples": 36749,
  "loopLengthSamples": 2351997,
  "loopStartSec": 0.833,
  "loopEndSec": 54.167
}
```

**Note:** Audio definitions are automatically loaded by `ModLoader` into `DefinitionRegistry` with `DefinitionType = "audio"`. No additional loading code is needed.

#### Map Music Assignment

Maps can specify music via `MusicComponent` in map definitions or via component attachment:

**Option 1: In Map Definition JSON**
```json
{
  "id": "map_littleroot_town",
  "type": "map",
  "music": {
    "audioId": "base:audio:music/towns/mus_littleroot",
    "fadeInOnTransition": true,
    "fadeDuration": 1.0
  }
}
```

**Option 2: Programmatically**
```csharp
// In MapLoaderSystem after creating map entity
World.Add(mapEntity, new MusicComponent
{
    AudioId = "base:audio:music/towns/mus_littleroot",
    FadeInOnTransition = true,
    FadeDuration = 1.0f
});
```

**Note:** The `audioId` must match an existing audio definition ID from `DefinitionRegistry`.

### 9. Cross-Platform Considerations

#### PortAudio for Cross-Platform Audio

- **Windows**: PortAudio uses DirectSound/XAudio2
- **Mac**: PortAudio uses CoreAudio
- **Linux**: PortAudio uses ALSA/PulseAudio

PortAudio abstracts platform differences and provides:
- Consistent API across platforms
- Low-latency audio output
- Thread-safe audio callbacks
- Automatic device management

#### NVorbis for OGG Vorbis Support

- **OGG Vorbis**: Fully supported via NVorbis library
  - Streaming support (reads samples on-demand)
  - Thread-safe reading
  - Seek support (by sample or time)
  - Metadata extraction

#### File Format Support

- **OGG Vorbis**: Fully supported via NVorbis (recommended, already standard)
- **WAV**: Could be added via custom reader (not currently used)
- **MP3**: Not supported (use OGG Vorbis instead)

**Current Audio Files:**
All existing audio files in `Mods/pokemon-emerald/Audio/` are OGG Vorbis format, which works perfectly with NVorbis.

**Recommendation:** Continue using OGG Vorbis for all audio (music and SFX) as it's already the standard and fully supported.

### 10. Error Handling

**Fail-Fast for Invalid State:**
- Throw `ArgumentNullException` for null dependencies
- Throw `InvalidOperationException` for invalid state
- Throw `ArgumentException` for invalid argument values

**Graceful Degradation for Missing Resources:**
- Return `null` for missing audio files (matching existing pattern from `SpriteLoaderService`)
- Log warnings for missing files
- Don't throw exceptions for missing resources (allows game to continue)

**Example (AudioContentLoader):**
```csharp
public VorbisReader? CreateVorbisReader(string audioId, AudioDefinition definition, ModManifest modManifest)
{
    if (string.IsNullOrEmpty(audioId))
    {
        throw new ArgumentException("Audio ID cannot be null or empty.", nameof(audioId));
    }
    
    if (definition == null)
    {
        throw new ArgumentNullException(nameof(definition));
    }
    
    if (modManifest == null)
    {
        throw new ArgumentNullException(nameof(modManifest));
    }
    
    // Resolve audio file path (following SpriteLoaderService pattern)
    string audioPath = Path.Combine(modManifest.ModDirectory, definition.AudioPath);
    audioPath = Path.GetFullPath(audioPath);
    
    if (!File.Exists(audioPath))
    {
        _logger.Warning(
            "Audio file not found: {AudioPath} (audio: {AudioId})",
            audioPath,
            audioId
        );
        return null;  // ✅ Return null, don't throw (matches existing pattern)
    }
    
    try
    {
        return new VorbisReader(audioPath);
    }
    catch (Exception ex)
    {
        _logger.Error(ex, "Failed to create VorbisReader for {AudioId} from {AudioPath}", audioId, audioPath);
        return null;
    }
}
```

**Example (System Error Handling):**
```csharp
// In SoundEffectSystem.Update()
var definition = _registry.GetById<AudioDefinition>(request.AudioId);
if (definition == null)
{
    _logger.Warning("Audio definition not found: {AudioId}", request.AudioId);
    World.Remove<SoundEffectRequestComponent>(entity);
    return;  // ✅ Gracefully skip, don't throw
}
```

## Implementation Phases

### Phase 1: Core Infrastructure
- `IAudioEngine` / `AudioEngine` implementation
- `IAudioContentLoader` / `AudioContentLoader` implementation
- Audio definition loading from mods
- Basic volume management

### Phase 2: Music System
- `MusicComponent` component
- `MapMusicSystem` system (handles map transitions)
- `MusicPlaybackSystem` system (handles music playback events)
- `PlayMusicEvent` / `StopMusicEvent` events
- OGG Vorbis metadata parsing (loop points)
- Basic music playback (no crossfading yet)

### Phase 3: Sound Effects
- `SoundEffectRequestComponent` component
- `SoundEffectSystem` system
- `PlaySoundEffectEvent` event
- Sound effect pooling (optional optimization)

### Phase 4: Advanced Features
- Crossfading support
- Ambient sounds (`AmbientSoundComponent` + system)
- Volume events and persistence
- Audio settings UI integration

## Comparison with oldmonoball

### Improvements

1. **ECS-Based**: Audio state managed through components, not services
2. **Event-Driven**: All operations via events, better decoupling
3. **Mod Integration**: Audio definitions loaded like other mod definitions
4. **Fail-Fast**: No fallback code, clear error messages
5. **Cleaner Architecture**: Better separation of concerns, systems handle logic

### Key Differences from oldmonoball

1. **ECS Systems**: Audio logic in ECS systems instead of services
2. **Event-Driven**: All operations via events (no direct service calls)
3. **Component-Based**: Audio state in components (`MusicComponent`, `SoundEffectRequestComponent`)
4. **Unified Definitions**: Uses `DefinitionRegistry` like other definition types
5. **Same Audio Libraries**: Still uses PortAudio + NVorbis (required for OGG loop points and crossfading)

## File Structure

```
MonoBall.Core/
├── Audio/
│   ├── AudioDefinition.cs          # Audio definition class
│   ├── IAudioEngine.cs
│   ├── AudioEngine.cs
│   ├── IAudioContentLoader.cs
│   └── AudioContentLoader.cs
├── ECS/
│   ├── Components/
│   │   └── Audio/
│   │       ├── MusicComponent.cs
│   │       ├── SoundEffectRequestComponent.cs
│   │       └── AmbientSoundComponent.cs
│   ├── Systems/
│   │   └── Audio/
│   │       ├── MapMusicSystem.cs
│   │       ├── MusicPlaybackSystem.cs
│   │       ├── SoundEffectSystem.cs
│   │       ├── AmbientSoundSystem.cs
│   │       └── AudioVolumeSystem.cs
│   └── Events/
│       └── Audio/
│           ├── PlayMusicEvent.cs
│           ├── StopMusicEvent.cs
│           ├── PlaySoundEffectEvent.cs
│           ├── SetMasterVolumeEvent.cs
│           ├── SetMusicVolumeEvent.cs
│           └── SetSoundEffectVolumeEvent.cs
```

**Namespace Structure:**
- `MonoBall.Core.Audio` - Audio services and definitions
- `MonoBall.Core.ECS.Components.Audio` - Audio components
- `MonoBall.Core.ECS.Systems.Audio` - Audio systems
- `MonoBall.Core.ECS.Events.Audio` - Audio events

## Dependencies

- **PortAudioSharp**: Cross-platform audio output library
  - Provides `PortAudioOutput` for audio playback
  - Handles platform differences (Windows/Mac/Linux)
  - Thread-safe audio callbacks

- **NVorbis**: OGG Vorbis file reading library
  - Provides `NVorbis.VorbisReader` for streaming OGG files
  - Thread-safe sample reading
  - Seek support

- **DefinitionRegistry**: Already exists, loads audio definitions from mods
- **ModManager**: Already exists, provides mod directory resolution
- **System.IO**: File operations
- **Arch.Core/Arch.System**: ECS framework

**Note:** Loop point metadata is already stored in audio definition JSON files (`loopStartSamples`, `loopLengthSamples`, `loopStartSec`, `loopEndSec`). The audio system will read these values from the definition and use them for seamless looping.

## Testing Strategy

1. **Unit Tests**: Test audio engine, content loader, metadata parsing
2. **Integration Tests**: Test systems with mock world
3. **Manual Testing**: Verify cross-platform playback, loop points, crossfading

## Future Enhancements

1. **3D Audio**: Positional sound effects based on entity positions
2. **Audio Zones**: Different music in different map regions
3. **Dynamic Music**: Music that changes based on game state
4. **Audio Debug UI**: Visualize playing sounds, volumes, etc.


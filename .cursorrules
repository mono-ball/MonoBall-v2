# MonoBall Project - Cursor Rules

This document defines coding standards and best practices for the MonoBall project, ensuring consistency, maintainability, and adherence to MonoGame conventions, .NET 10 C# best practices, SOLID principles, and DRY methodology.

## ⚠️ CRITICAL RULES - READ FIRST ⚠️

**These rules MUST be followed in all code changes:**

1. **NO BACKWARD COMPATIBILITY** - Refactor APIs freely, break existing code if needed, update all call sites
2. **NO FALLBACK CODE** - Fail fast with clear exceptions, never silently degrade or use default values for required dependencies
3. **ECS Systems**: Inherit from `BaseSystem<World, float>`, cache `QueryDescription` in constructor, never create queries in Update/Render
4. **ECS Components**: Value types (`struct`) only, data not behavior, end names with `Component` suffix
5. **Event Subscriptions**: MUST implement `IDisposable` and unsubscribe in `Dispose()` to prevent leaks
6. **Nullable Types**: Always enable nullable reference types, use `?` for nullable, validate nulls with exceptions
7. **Dependency Injection**: Required dependencies in constructor, throw `ArgumentNullException` for null
8. **XML Documentation**: Document all public APIs with XML comments
9. **Namespace**: Match folder structure, root is `MonoBall.Core`
10. **File Organization**: One class per file, PascalCase naming, match file name to class name

---

## Project Context
- **Framework**: MonoGame 3.8+ with .NET 10.0
- **Language**: C# with nullable reference types enabled
- **Architecture**: Mod-based game engine with ECS (Entity Component System) architecture
- **ECS Library**: Arch ECS (Arch.Core, Arch.System)
- **Event System**: Custom `EventBus` static class in `MonoBall.Core.ECS` namespace
- **Code Style**: Clean, SOLID, DRY principles

---

## Development Philosophy

### No Backward Compatibility
- **NEVER maintain backward compatibility** - refactor APIs freely when improvements are needed
- **Break existing code if necessary** - update all call sites to use new APIs
- **Remove deprecated code immediately** - don't keep old implementations alongside new ones
- **Update all usages** - when changing an API, find and update all call sites rather than maintaining compatibility layers

### No Fallback Code
- **NEVER introduce fallback code** - code should fail fast with clear errors rather than silently degrade
- **Require all dependencies** - if a method needs a service or component, make it required (non-nullable)
- **Throw exceptions for missing requirements** - use `InvalidOperationException` or `ArgumentNullException` with clear messages
- **No default values for critical dependencies** - don't use optional parameters or null defaults for required services
- **Validate all prerequisites** - check for required components/services and throw exceptions if missing

#### ❌ Bad: Fallback Code
```csharp
private Vector2 CalculateEntityCenter(Entity entity, Vector2 position)
{
    if (_spriteLoader != null && World.Has<SpriteSheetComponent>(entity))
    {
        return CalculateFromSprite(entity, position);
    }
    return new Vector2(position.X + 8f, position.Y + 16f); // Fallback
}
```

#### ✅ Good: Fail Fast
```csharp
private Vector2 CalculateEntityCenter(Entity entity, Vector2 position)
{
    if (!World.Has<SpriteSheetComponent>(entity))
    {
        throw new InvalidOperationException(
            $"Entity {entity.Id} does not have SpriteSheetComponent. " +
            "Cannot calculate sprite center without sprite sheet information."
        );
    }
    return CalculateFromSprite(entity, position);
}
```

---

## .NET 10 C# Best Practices

### General Guidelines
- **Always enable nullable reference types**: `<Nullable>enable</Nullable>` in csproj
- **Use modern C# features**: Pattern matching, nullable reference types, init-only properties
- **Prefer expression-bodied members** for simple properties/methods
- **Use `var`** when type is obvious, avoid when it reduces readability
- **Use null-conditional operators** (`?.`, `??`) appropriately
- **Prefer `string.IsNullOrEmpty()` and `string.IsNullOrWhiteSpace()`** over manual checks
- **Use `IReadOnlyList<T>`** for read-only collections
- **Prefer `IEnumerable<T>`** for method parameters when mutation isn't needed

### Exception Handling
- **Catch specific exceptions**, not `Exception` unless absolutely necessary
- **Validate arguments** and throw `ArgumentNullException` or `ArgumentException` with parameter names
- **Document exceptions** in XML comments using `<exception>` tags

### Collections & Performance
- **Prefer `List<T>`** over arrays when size may change
- **Use `Dictionary<TKey, TValue>`** for key-value lookups
- **Avoid allocations** in Update/Draw loops (object pooling for frequently created objects)
- **Pre-size collections** when size is known (`new List<T>(capacity)`)
- **Reuse collections in hot paths**: Cache `List<T>` or other collections as instance fields, clear and reuse them instead of allocating new ones in Update/Render methods

---

## SOLID Principles

- **Single Responsibility**: Each class should have one reason to change
- **Open/Closed**: Open for extension, closed for modification (use interfaces/abstractions)
- **Liskov Substitution**: Derived classes must be substitutable for their base classes
- **Interface Segregation**: Clients shouldn't depend on interfaces they don't use
- **Dependency Inversion**: Depend on abstractions, not concretions (use interfaces, inject dependencies)

---

## DRY (Don't Repeat Yourself)

- **Extract common logic** into methods or classes
- **Create utility classes** for shared functionality
- **Avoid copy-paste code** - refactor into shared methods
- **Use extension methods** for common operations on types you don't control
- **Define constants** for magic numbers and strings

---

## MonoGame Best Practices

### Game Loop
- **Use `GameTime`** for frame-independent updates (don't assume 60 FPS)
- **Separate Update and Draw logic** clearly
- **Avoid heavy computations** in Draw methods; pre-calculate when possible
- **ECS System Updates**: Update in `Game.Update()` using `Group<T>.BeforeUpdate()`, `Update()`, `AfterUpdate()` with deltaTime
- **ECS Rendering**: Call render methods from `Game.Draw()` for rendering systems
- **Convert GameTime to deltaTime**: Use `(float)gameTime.ElapsedGameTime.TotalSeconds`

### Graphics & Input
- **Use `SpriteBatch`** for 2D rendering, call `Begin()` and `End()` appropriately
- **Minimize state changes** between draw calls
- **Check input state** in Update, not Draw
- **Cache frequently accessed properties** (e.g., `GraphicsDevice`, `Window`)

---

## File Organization

### Namespace Structure
- **Match namespace to folder structure**
- **Root namespace**: `MonoBall.Core`
- **Sub-namespaces** match subdirectories (e.g., `MonoBall.Core.Mods`, `MonoBall.Core.Mods.Utilities`)
- **One class per file** (except closely related classes like enums and helpers)

### Directory Structure
```
MonoBall.Core/
├── ECS/               # Entity Component System
│   ├── Components/    # ECS components (value types)
│   ├── Systems/       # ECS systems (behavior/logic)
│   ├── Events/        # ECS event definitions
│   ├── Services/      # ECS-related services
│   ├── EventBus.cs    # Custom event bus implementation
│   ├── EcsService.cs  # ECS service wrapper
│   └── EcsWorld.cs    # ECS world singleton
├── Scenes/            # Scene system (pure ECS)
│   ├── Components/   # Scene components
│   ├── Systems/       # Scene-specific systems
│   └── Events/        # Scene event definitions
├── Scripting/         # Scripting system
│   ├── Api/           # Script API interfaces
│   ├── Runtime/       # Script runtime classes
│   ├── Services/      # Script loading/compilation services
│   └── Utilities/     # Script utilities
├── Rendering/         # Rendering services (shaders, render targets)
├── Resources/         # Resource management
├── Audio/             # Audio engine and services
├── Constants/         # Constants system
├── TextEffects/       # Text effect system
├── UI/                # UI windows and components
├── Mods/              # Mod system classes
└── Maps/              # Map-related classes
```

### File Naming & Code Organization
- **Use PascalCase** for class names and file names (e.g., `ModManager.cs`)
- **Match file name to primary class name**
- **Code order**: Using statements → Namespace → XML docs → Constants/Fields → Properties → Constructors → Public methods → Protected → Private

---

## Documentation Standards

- **Document all public APIs** with XML comments (`<summary>`, `<param>`, `<returns>`, `<exception>`)
- **Use comments to explain "why", not "what"** (code should be self-explanatory)
- **Avoid commented-out code** - remove it or explain why it's kept

---

## Type Safety and Nullability

- **Use `?` suffix** for nullable reference types (e.g., `string?`, `ModManager?`)
- **Use null-forgiving operator `!`** sparingly and only when certain a value isn't null
- **Prefer null-conditional operators** (`?.`, `??`) over null checks when appropriate
- **Return null** only when null is a valid, expected state (document in XML comments)

---

## Error Handling and Validation

- **Validate method parameters** at the beginning of methods
- **Throw `ArgumentNullException`** for null arguments
- **Throw `ArgumentException`** for invalid argument values
- **Throw `InvalidOperationException`** for invalid state
- **Include parameter name** in exception messages
- **Use guard clauses** for early returns in validation

---

## Arch ECS Best Practices

### Components
- **Components are value types** (`struct`) - store data, not behavior
- **Keep components small and focused** - each component represents a single aspect
- **Naming**: End component names with `Component` suffix (e.g., `PositionComponent`)
- **Location**: `ECS/Components/` directory, namespace `MonoBall.Core.ECS.Components`
- **Keep components pure data** - no methods, only properties

### Systems
- **Inherit from `BaseSystem<World, float>`** (World parameter, float deltaTime)
- **Systems contain logic**, not data - they operate on components
- **Cache QueryDescription**: Store as instance fields (created in constructor) or static readonly fields
- **NEVER create QueryDescription in Update/Render methods** - always cache them
- **Naming**: End system names with `System` suffix (e.g., `MapLoaderSystem`)
- **Location**: `ECS/Systems/` directory, namespace `MonoBall.Core.ECS.Systems`
- **Inject dependencies** through constructor (World, services, managers)
- **Optional dependencies**: Use nullable types for optional dependencies (e.g., `ShaderManagerSystem?`), check for null before use, document in XML comments
- **Separate update and render methods**: Systems can have both `Update()` and `Render()` methods, but keep the logic separated - update logic in `Update()`, render logic in `Render()`
- **Reusable collections**: Cache collections as instance fields (e.g., `List<T>`) to avoid allocations in hot paths - clear and reuse them in Update/Render methods

### System Organization
- **Use `Group<T>`** to organize related systems (e.g., "MapSystems", "RenderSystems")
- **Call lifecycle methods**: `BeforeUpdate()`, `Update()`, `AfterUpdate()` in that order
- **Update systems in `Game.Update()`**: Pass deltaTime as `(float)gameTime.ElapsedGameTime.TotalSeconds`
- **Render systems separately**: Call render methods from `Game.Draw()`, not through Group
- **Systems with both Update and Render**: It's acceptable for a system to have both `Update()` and `Render()` methods - they are separate methods with separate responsibilities

### System Disposal (IDisposable)
- **Implement `IDisposable`** only when system has managed resources (event subscriptions, cached collections)
- **Event subscriptions require disposal**: If subscribing to events, MUST implement `IDisposable` and unsubscribe in `Dispose()`
- **Use standard dispose pattern** with protected `Dispose(bool disposing)` method
- **Use `new` keyword** on public `Dispose()` if `BaseSystem` has a `Dispose()` method
- **Call `GC.SuppressFinalize(this)`** when implementing the standard dispose pattern with `Dispose(bool disposing)` - this is correct even without a finalizer
- **Always check `_disposed` flag** to prevent multiple disposals

#### Dispose Pattern Template
```csharp
public class MySystem : BaseSystem<World, float>, IDisposable
{
    private readonly List<IDisposable> _subscriptions = new();
    private bool _disposed = false;

    public MySystem(World world) : base(world)
    {
        // Store IDisposable subscriptions for automatic cleanup
        _subscriptions.Add(EventBus.Subscribe<SomeEvent>(OnSomeEvent));
        _subscriptions.Add(EventBus.Subscribe<OtherEvent>(OnOtherEvent));
    }

    public new void Dispose() => Dispose(true);

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed && disposing)
        {
            // Dispose all subscriptions (thread-safe, idempotent)
            foreach (var subscription in _subscriptions)
                subscription.Dispose();
            // Clear cached collections, dispose other resources
        }
        _disposed = true;
    }
}
```

### Query Performance
- **Cache QueryDescription**: Create in constructor, store as instance field or static readonly
- **Multiple queries per system**: Systems can have multiple cached queries (e.g., `_npcQuery`, `_playerQuery`) for different entity types
- **Use appropriate filters**: `WithAll` for AND, `WithAny` for OR, `WithNone` for exclusion
- **Single-pass queries**: Get all needed components in one query pass
- **Avoid allocations** in hot path queries - reuse collections or use stack allocation

#### QueryDescription Caching Examples
```csharp
// Instance field (most common)
public class SpriteRendererSystem : BaseSystem<World, float>
{
    private readonly QueryDescription _npcQuery;
    private readonly QueryDescription _playerQuery;
    
    public SpriteRendererSystem(World world) : base(world)
    {
        _npcQuery = new QueryDescription().WithAll<NpcComponent, SpriteAnimationComponent>();
        _playerQuery = new QueryDescription().WithAll<PlayerComponent, SpriteSheetComponent>();
    }
}

// Static readonly (when shared across instances)
public class SomeSystem : BaseSystem<World, float>
{
    private static readonly QueryDescription SharedQuery = new QueryDescription()
        .WithAll<SomeComponent>();
}
```

### Entity Management
- **Create entities** with `World.Create()` and pass initial components
- **Destroy entities** with `World.Destroy()` when no longer needed
- **Avoid storing Entity references** long-term - use component data instead

### Example: Component
```csharp
namespace MonoBall.Core.ECS.Components
{
    /// <summary>
    /// Component that stores world position for entities.
    /// </summary>
    public struct PositionComponent
    {
        /// <summary>
        /// The world position in pixels.
        /// </summary>
        public Vector2 Position { get; set; }
    }
}
```

### Example: System with Manual Query and Reusable Collections
```csharp
public class MapRendererSystem : BaseSystem<World, float>
{
    private readonly GraphicsDevice _graphicsDevice;
    private readonly QueryDescription _queryDescription;
    
    // Reusable collection to avoid allocations in hot path
    private readonly List<(
        Entity entity,
        TileChunkComponent chunk,
        PositionComponent pos,
        RenderableComponent render
    )> _chunkList = new();
    
    public MapRendererSystem(
        World world,
        GraphicsDevice graphicsDevice,
        ShaderManagerSystem? shaderManagerSystem = null  // Optional dependency
    ) : base(world)
    {
        _graphicsDevice = graphicsDevice ?? throw new ArgumentNullException(nameof(graphicsDevice));
        _shaderManagerSystem = shaderManagerSystem;  // Nullable, check before use
        _queryDescription = new QueryDescription()
            .WithAll<TileChunkComponent, PositionComponent, RenderableComponent>();
    }
    
    public override void Update(in float deltaTime)
    {
        // Clear reusable collection instead of allocating new one
        _chunkList.Clear();
        
        World.Query(in _queryDescription, (ref TileChunkComponent chunk, ref PositionComponent pos, ref RenderableComponent render) =>
        {
            if (render.IsVisible)
            {
                // Collect entities for processing
                _chunkList.Add((entity, chunk, pos, render));
            }
        });
        
        // Process collected entities
        foreach (var (entity, chunk, pos, render) in _chunkList)
        {
            // Update logic
        }
    }
}
```

---

## Event System Best Practices

### Event Architecture
- **Use custom `EventBus`** static class in `MonoBall.Core.ECS` namespace for decoupled event communication
- **Thread-safe**: Uses `ConcurrentDictionary` for handler storage, lock-free publish path
- **IDisposable subscriptions**: Subscribe returns `IDisposable` for safe, automatic cleanup
- **Events are value types** (`struct`) - lightweight data containers
- **Naming**: End event names with `Event` suffix (e.g., `MapLoadedEvent`, `SceneCreatedEvent`)
- **Location**: Events can be in feature-specific directories:
  - `ECS/Events/` - General ECS events, namespace `MonoBall.Core.ECS.Events`
  - `Scenes/Events/` - Scene-specific events, namespace `MonoBall.Core.Scenes.Events`
  - Other feature areas can have their own `Events/` subdirectories
- **Events carry context**: Include relevant entity references, IDs, and state data

### EventBus API
- **`EventBus.Subscribe<T>(Action<T>)`** - Subscribe with copy handler, returns `IDisposable`
- **`EventBus.Subscribe<T>(RefAction<T>)`** - Subscribe with ref handler, returns `IDisposable`
- **`EventBus.Send<T>(ref T)`** - Broadcast event to all subscribers (pass by ref)
- **`EventBus.SendOnMainThread<T>(T)`** - Queue event for main thread dispatch (thread-safe)
- **`EventBus.ProcessMainThreadQueue()`** - Process queued events (call in Game.Update)
- **`EventBus.Initialize()`** - Set main thread reference (call once at startup)
- **`EventBus.SetErrorHandler(Action<string, Exception>)`** - Custom error handling

### Event Design & Publishing
- **Keep events focused** - represent a single occurrence or state change
- **Make events immutable** - use `readonly` properties or init-only setters
- **Document events** with XML comments explaining when they're fired
- **Use `EventBus.Send(ref evt)`** to broadcast events (takes ref parameter)
- **Fire events after state changes** are complete and valid

### Event Subscription
- **Subscribe to events** in systems that need to react to state changes
- **Store IDisposable subscriptions** in a `List<IDisposable>` field
- **Dispose subscriptions in `Dispose()`** to prevent memory leaks
- **Keep event handlers focused** - delegate to other methods if logic is complex
- **Use `ref` parameters** in handlers for zero-allocation struct events

### Example: Event Definition
```csharp
namespace MonoBall.Core.ECS.Events
{
    /// <summary>
    /// Event fired when a map is loaded.
    /// </summary>
    public struct MapLoadedEvent
    {
        public string MapId { get; set; }
        public Entity MapEntity { get; set; }
    }
}
```

### Example: Publishing & Subscribing (Custom EventBus)
```csharp
using MonoBall.Core.ECS;

// Publishing (pass by ref for struct events)
var loadedEvent = new MapLoadedEvent { MapId = mapId, MapEntity = mapEntity };
EventBus.Send(ref loadedEvent);

// Subscribing (in system constructor)
public class MySystem : BaseSystem<World, float>, IDisposable
{
    private readonly List<IDisposable> _subscriptions = new();
    private bool _disposed;

    public MySystem(World world) : base(world)
    {
        // Store subscriptions for cleanup
        _subscriptions.Add(EventBus.Subscribe<MapTransitionEvent>(OnMapTransition));
        _subscriptions.Add(EventBus.Subscribe<MapLoadedEvent>(OnMapLoaded));
    }

    private void OnMapTransition(MapTransitionEvent evt)
    {
        // Handler logic (copy of event)
    }

    // Ref handler for modifying event data
    private void OnMapLoaded(ref MapLoadedEvent evt)
    {
        // Handler logic (ref to event)
    }

    public new void Dispose() => Dispose(true);

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed && disposing)
        {
            foreach (var subscription in _subscriptions)
                subscription.Dispose();
        }
        _disposed = true;
    }
}
```

### Scene Events
- **Scene events** follow the same patterns as ECS events
- **Naming**: Scene events typically start with `Scene` prefix (e.g., `SceneCreatedEvent`, `SceneActivatedEvent`)
- **Location**: `Scenes/Events/` directory, namespace `MonoBall.Core.Scenes.Events`
- **Usage**: Scene systems publish events for lifecycle changes (create, activate, pause, destroy)

---

## Scene System Best Practices

### Scene Architecture (Pure ECS)
- **Scenes are entities with components** - no OOP scene classes, pure ECS approach
- **Scene components**: Scenes use marker components to identify type (e.g., `GameSceneComponent`, `LoadingSceneComponent`)
- **SceneSystem**: Manages scene lifecycle only (create, destroy, activate, pause) - does NOT handle update/render
- **Scene-specific systems**: Each scene type has its own system that implements `ISceneSystem`
- **Scene stack**: Scenes are managed in a priority stack by `SceneSystem`

### Scene System Pattern
- **Implement `ISceneSystem`** for scene-specific behavior
- **Query for scene entities** by their marker component type
- **Handle update and render** in the scene-specific system, not in `SceneSystem`
- **SceneSystem coordinates** but doesn't know about scene types

### Example: Scene-Specific System
```csharp
public class GameSceneSystem : BaseSystem<World, float>, ISceneSystem
{
    private readonly QueryDescription _sceneQuery;
    
    public GameSceneSystem(World world) : base(world)
    {
        _sceneQuery = new QueryDescription()
            .WithAll<SceneComponent, GameSceneComponent>();
    }
    
    public override void Update(in float deltaTime)
    {
        // Process all game scenes
        World.Query(in _sceneQuery, (ref SceneComponent scene) =>
        {
            if (scene.IsActive && !scene.IsPaused)
            {
                // Update logic
            }
        });
    }
    
    public void Update(Entity sceneEntity, float deltaTime)
    {
        // Per-scene update (called by SceneSystem)
    }
    
    public void RenderScene(Entity sceneEntity, GameTime gameTime)
    {
        // Per-scene render (called by SceneSystem)
    }
    
    public void ProcessInternal(float deltaTime)
    {
        // Internal processing if needed
    }
}
```

### Scene Events
- **Scene lifecycle events**: `SceneCreatedEvent`, `SceneActivatedEvent`, `ScenePausedEvent`, `SceneDestroyedEvent`
- **Publish events** after state changes are complete
- **Subscribe to events** in systems that need to react to scene changes

---

## Service Naming Conventions

### Service Classes
- **End with `Service` suffix**: `ScriptLoaderService`, `ResourceManager`, `CameraService`
- **Specialized services**:
  - `*LoaderService` - Loads resources/definitions (e.g., `ScriptLoaderService`)
  - `*CompilerService` - Compiles code (e.g., `ScriptCompilerService`)
  - `*Manager` - Manages lifecycle/collections (e.g., `ModManager`, `ResourceManager`)
  - `*Registry` - Manages registrations/lookups (e.g., `DefinitionRegistry`)
  - `*Factory` - Creates instances (e.g., `ConstantsServiceFactory`)

### Service Interfaces
- **Prefix with `I`**: `IScriptApiProvider`, `ICameraService`, `IResourceManager`
- **Match implementing class name**: `ICameraService` → `CameraService`
- **Define clear contracts**: Interfaces should be focused and not "fat"

### Service Location
- **Feature-specific services**: In feature directory (e.g., `Scripting/Services/`, `Rendering/`)
- **ECS services**: In `ECS/Services/` directory
- **Core services**: At root level or appropriate feature directory

---

## Scripting System Best Practices

### Script Architecture
- **Scripts inherit from `ScriptBase`**: Single unified base class for all script types
- **Event-driven**: Scripts subscribe to events via `On<T>()` method, no polling
- **ECS-first**: Scripts operate on entities/components, not OOP classes
- **Composable**: Multiple scripts can be attached to the same entity
- **Hot-reload safe**: Scripts automatically reload during development

### Script Organization
- **Script definitions**: JSON files in `Definitions/Scripts/` directory
- **Script files**: C# script files (`.csx`) in `Scripts/` directory
- **Script categories**: Organize by category (e.g., `Scripts/Behaviors/`, `Scripts/tile/`)
- **Auto-loaded**: Scripts are automatically discovered and loaded from mod directories

### Script APIs
- **APIs via `IScriptApiProvider`**: Scripts access game systems through provided APIs
- **API separation**: 
  - `ScriptBase` - Entity-specific convenience methods
  - `IScriptApiProvider` - Game system operations and cross-entity interactions
  - Utilities - Pure functions and parsing helpers
- **No direct system access**: Scripts should not directly access ECS systems

### Example: Script Definition
```json
{
  "id": "base:script:behaviors/wander",
  "name": "Wander Behavior",
  "scriptPath": "Scripts/Behaviors/wander_behavior.csx",
  "parameters": {
    "rangeX": 5,
    "rangeY": 5,
    "speed": 1.0
  }
}
```

### Example: Script Implementation
```csharp
public class WanderBehavior : ScriptBase
{
    protected override void OnStart()
    {
        // Subscribe to events
        On<MovementCompletedEvent>(OnMovementCompleted);
    }
    
    private void OnMovementCompleted(ref MovementCompletedEvent evt)
    {
        // Event-driven behavior logic
        var randomDirection = GetRandomDirection();
        Api.Movement.Move(Context.Entity, randomDirection);
    }
}
```

---

## System Interfaces

### When to Use System Interfaces
- **Loose coupling**: Use interfaces when systems need to interact without tight coupling
- **Testability**: Interfaces enable easier mocking and testing
- **Flexibility**: Allows swapping implementations without changing dependent code

### Common System Interfaces
- **`ISceneSystem`**: For scene-specific systems that handle update/render for scene types
- **`IPrioritizedSystem`**: For systems that need priority ordering in update loops
- **`ISceneManager`**: For systems that manage scene lifecycle

### Example: System Interface Usage
```csharp
// Define interface
public interface ISceneSystem
{
    void Update(Entity sceneEntity, float deltaTime);
    void RenderScene(Entity sceneEntity, GameTime gameTime);
    void ProcessInternal(float deltaTime);
}

// Implement in scene-specific system
public class GameSceneSystem : BaseSystem<World, float>, ISceneSystem
{
    // Implementation
}

// Use interface for loose coupling
public class SceneSystem : BaseSystem<World, float>
{
    private readonly Dictionary<Type, ISceneSystem> _sceneSystemRegistry;
    
    public void RegisterSceneSystem(Type componentType, ISceneSystem system)
    {
        _sceneSystemRegistry[componentType] = system;
    }
}
```

---

## Mod System Guidelines

- **Validate mods before loading** using `ModValidator`
- **Handle loading errors gracefully** - log errors but don't crash
- **Use strongly-typed definitions** with generics (`GetDefinition<T>()`)
- **Store definitions in registry** for efficient lookup

---

## Anti-Patterns to Avoid

### General
- ❌ **God classes** - classes that do too much
- ❌ **Magic numbers and strings** - use constants or configuration
- ❌ **Unchecked null references** - use nullable types properly
- ❌ **Heavy computation in Draw()** - pre-calculate or cache
- ❌ **Creating objects in Update/Draw loops** - reuse or pool
- ❌ **Ignoring GameTime** - don't assume fixed frame rate
- ❌ **Tight coupling** - use interfaces and dependency injection
- ❌ **Copy-paste code** - extract to shared methods/classes
- ❌ **Maintaining backward compatibility** - refactor freely, update all call sites
- ❌ **Fallback code** - fail fast with clear exceptions

### ECS-Specific
- ❌ **Storing behavior in components** - components are data only
- ❌ **Large components** - split into focused, cohesive components
- ❌ **Direct system-to-system calls** - use events for communication
- ❌ **Storing Entity references in components** - use IDs or component relationships
- ❌ **Creating QueryDescription in hot paths** - always cache them
- ❌ **Double querying** - get all needed components in one pass
- ❌ **Allocations in queries** - reuse collections or use stack allocation
- ❌ **Mixing update and render logic in the same method** - keep update logic in `Update()` and render logic in `Render()` (systems can have both methods, but logic must be separated)
- ❌ **Not disposing event subscriptions** - unsubscribe in Dispose() to prevent leaks
- ❌ **Allocating new collections in Update/Render** - reuse cached collections instead
- ❌ **Scene classes with behavior** - scenes are entities with components, systems handle behavior

### Event-Specific
- ❌ **Events with side effects** - events carry data, not behavior
- ❌ **Circular event dependencies** - avoid events triggering events that trigger the first
- ❌ **Events for every state change** - only fire for significant, observable changes

---

## Code Examples

### Good: Dependency Injection
```csharp
public class ModLoader
{
    private readonly string _modsDirectory;
    private readonly DefinitionRegistry _registry;
    
    public ModLoader(string modsDirectory, DefinitionRegistry registry)
    {
        _modsDirectory = modsDirectory ?? throw new ArgumentNullException(nameof(modsDirectory));
        _registry = registry ?? throw new ArgumentNullException(nameof(registry));
    }
}
```

### Good: Exception Handling
```csharp
public void Register(DefinitionMetadata metadata)
{
    if (_isLocked)
    {
        throw new InvalidOperationException("DefinitionRegistry is locked and cannot be modified.");
    }
    
    if (string.IsNullOrEmpty(metadata.Id))
    {
        throw new ArgumentException("Definition ID cannot be null or empty.", nameof(metadata));
    }
    
    // Registration logic
}
```

### Good: Optional Dependencies
```csharp
public class SpriteRendererSystem : BaseSystem<World, float>
{
    private readonly ShaderManagerSystem? _shaderManagerSystem;
    
    /// <summary>
    /// Initializes a new instance of the SpriteRendererSystem.
    /// </summary>
    /// <param name="shaderManagerSystem">Optional shader manager system for sprite layer shaders.</param>
    public SpriteRendererSystem(
        World world,
        ShaderManagerSystem? shaderManagerSystem = null
    ) : base(world)
    {
        _shaderManagerSystem = shaderManagerSystem;
    }
    
    public override void Update(in float deltaTime)
    {
        // Check for null before using optional dependency
        if (_shaderManagerSystem != null)
        {
            // Use shader system
        }
    }
}
```

### Good: Reusable Collections Pattern
```csharp
public class SpriteRendererSystem : BaseSystem<World, float>
{
    // Cache collection as instance field
    private readonly List<(Entity entity, SpriteAnimationComponent anim, PositionComponent pos)> _spriteList = new();
    
    public override void Update(in float deltaTime)
    {
        // Clear instead of allocating new list
        _spriteList.Clear();
        
        World.Query(in _queryDescription, (ref SpriteAnimationComponent anim, ref PositionComponent pos) =>
        {
            _spriteList.Add((entity, anim, pos));
        });
        
        // Process collected sprites
        foreach (var (entity, anim, pos) in _spriteList)
        {
            // Process sprite
        }
    }
}
```

# MonoBall Project - Cursor Rules

This document defines coding standards and best practices for the MonoBall project, ensuring consistency, maintainability, and adherence to MonoGame conventions, .NET 10 C# best practices, SOLID principles, and DRY methodology.

## ⚠️ CRITICAL RULES - READ FIRST ⚠️

**These rules MUST be followed in all code changes:**

1. **NO BACKWARD COMPATIBILITY** - Refactor APIs freely, break existing code if needed, update all call sites
2. **NO FALLBACK CODE** - Fail fast with clear exceptions, never silently degrade or use default values for required dependencies
3. **ECS Systems**: Inherit from `BaseSystem<World, float>`, cache `QueryDescription` in constructor, never create queries in Update/Render
4. **ECS Components**: Value types (`struct`) only, data not behavior, end names with `Component` suffix
5. **Event Subscriptions**: MUST implement `IDisposable` and unsubscribe in `Dispose()` to prevent leaks
6. **Nullable Types**: Always enable nullable reference types, use `?` for nullable, validate nulls with exceptions
7. **Dependency Injection**: Required dependencies in constructor, throw `ArgumentNullException` for null
8. **XML Documentation**: Document all public APIs with XML comments
9. **Namespace**: Match folder structure, root is `MonoBall.Core`
10. **File Organization**: One class per file, PascalCase naming, match file name to class name

---

## Project Context
- **Framework**: MonoGame 3.8+ with .NET 10.0
- **Language**: C# with nullable reference types enabled
- **Architecture**: Mod-based game engine with ECS (Entity Component System) architecture
- **ECS Library**: Arch ECS (Arch.Core, Arch.System, Arch.EventBus)
- **Code Style**: Clean, SOLID, DRY principles

---

## Development Philosophy

### No Backward Compatibility
- **NEVER maintain backward compatibility** - refactor APIs freely when improvements are needed
- **Break existing code if necessary** - update all call sites to use new APIs
- **Remove deprecated code immediately** - don't keep old implementations alongside new ones
- **Update all usages** - when changing an API, find and update all call sites rather than maintaining compatibility layers

### No Fallback Code
- **NEVER introduce fallback code** - code should fail fast with clear errors rather than silently degrade
- **Require all dependencies** - if a method needs a service or component, make it required (non-nullable)
- **Throw exceptions for missing requirements** - use `InvalidOperationException` or `ArgumentNullException` with clear messages
- **No default values for critical dependencies** - don't use optional parameters or null defaults for required services
- **Validate all prerequisites** - check for required components/services and throw exceptions if missing

#### ❌ Bad: Fallback Code
```csharp
private Vector2 CalculateEntityCenter(Entity entity, Vector2 position)
{
    if (_spriteLoader != null && World.Has<SpriteSheetComponent>(entity))
    {
        return CalculateFromSprite(entity, position);
    }
    return new Vector2(position.X + 8f, position.Y + 16f); // Fallback
}
```

#### ✅ Good: Fail Fast
```csharp
private Vector2 CalculateEntityCenter(Entity entity, Vector2 position)
{
    if (!World.Has<SpriteSheetComponent>(entity))
    {
        throw new InvalidOperationException(
            $"Entity {entity.Id} does not have SpriteSheetComponent. " +
            "Cannot calculate sprite center without sprite sheet information."
        );
    }
    return CalculateFromSprite(entity, position);
}
```

---

## .NET 10 C# Best Practices

### General Guidelines
- **Always enable nullable reference types**: `<Nullable>enable</Nullable>` in csproj
- **Use modern C# features**: Pattern matching, nullable reference types, init-only properties
- **Prefer expression-bodied members** for simple properties/methods
- **Use `var`** when type is obvious, avoid when it reduces readability
- **Use null-conditional operators** (`?.`, `??`) appropriately
- **Prefer `string.IsNullOrEmpty()` and `string.IsNullOrWhiteSpace()`** over manual checks
- **Use `IReadOnlyList<T>`** for read-only collections
- **Prefer `IEnumerable<T>`** for method parameters when mutation isn't needed

### Exception Handling
- **Catch specific exceptions**, not `Exception` unless absolutely necessary
- **Validate arguments** and throw `ArgumentNullException` or `ArgumentException` with parameter names
- **Document exceptions** in XML comments using `<exception>` tags

### Collections & Performance
- **Prefer `List<T>`** over arrays when size may change
- **Use `Dictionary<TKey, TValue>`** for key-value lookups
- **Avoid allocations** in Update/Draw loops (object pooling for frequently created objects)
- **Pre-size collections** when size is known (`new List<T>(capacity)`)

---

## SOLID Principles

- **Single Responsibility**: Each class should have one reason to change
- **Open/Closed**: Open for extension, closed for modification (use interfaces/abstractions)
- **Liskov Substitution**: Derived classes must be substitutable for their base classes
- **Interface Segregation**: Clients shouldn't depend on interfaces they don't use
- **Dependency Inversion**: Depend on abstractions, not concretions (use interfaces, inject dependencies)

---

## DRY (Don't Repeat Yourself)

- **Extract common logic** into methods or classes
- **Create utility classes** for shared functionality
- **Avoid copy-paste code** - refactor into shared methods
- **Use extension methods** for common operations on types you don't control
- **Define constants** for magic numbers and strings

---

## MonoGame Best Practices

### Game Loop
- **Use `GameTime`** for frame-independent updates (don't assume 60 FPS)
- **Separate Update and Draw logic** clearly
- **Avoid heavy computations** in Draw methods; pre-calculate when possible
- **ECS System Updates**: Update in `Game.Update()` using `Group<T>.BeforeUpdate()`, `Update()`, `AfterUpdate()` with deltaTime
- **ECS Rendering**: Call render methods from `Game.Draw()` for rendering systems
- **Convert GameTime to deltaTime**: Use `(float)gameTime.ElapsedGameTime.TotalSeconds`

### Graphics & Input
- **Use `SpriteBatch`** for 2D rendering, call `Begin()` and `End()` appropriately
- **Minimize state changes** between draw calls
- **Check input state** in Update, not Draw
- **Cache frequently accessed properties** (e.g., `GraphicsDevice`, `Window`)

---

## File Organization

### Namespace Structure
- **Match namespace to folder structure**
- **Root namespace**: `MonoBall.Core`
- **Sub-namespaces** match subdirectories (e.g., `MonoBall.Core.Mods`, `MonoBall.Core.Mods.Utilities`)
- **One class per file** (except closely related classes like enums and helpers)

### Directory Structure
```
MonoBall.Core/
├── ECS/               # Entity Component System
│   ├── Components/    # ECS components (value types)
│   ├── Systems/       # ECS systems (behavior/logic)
│   ├── Events/        # Event definitions
│   ├── EcsService.cs  # ECS service wrapper
│   └── EcsWorld.cs    # ECS world singleton
├── Mods/              # Mod system classes
├── Maps/              # Map-related classes
└── [Feature Areas]/   # Other feature-specific folders
```

### File Naming & Code Organization
- **Use PascalCase** for class names and file names (e.g., `ModManager.cs`)
- **Match file name to primary class name**
- **Code order**: Using statements → Namespace → XML docs → Constants/Fields → Properties → Constructors → Public methods → Protected → Private

---

## Documentation Standards

- **Document all public APIs** with XML comments (`<summary>`, `<param>`, `<returns>`, `<exception>`)
- **Use comments to explain "why", not "what"** (code should be self-explanatory)
- **Avoid commented-out code** - remove it or explain why it's kept

---

## Type Safety and Nullability

- **Use `?` suffix** for nullable reference types (e.g., `string?`, `ModManager?`)
- **Use null-forgiving operator `!`** sparingly and only when certain a value isn't null
- **Prefer null-conditional operators** (`?.`, `??`) over null checks when appropriate
- **Return null** only when null is a valid, expected state (document in XML comments)

---

## Error Handling and Validation

- **Validate method parameters** at the beginning of methods
- **Throw `ArgumentNullException`** for null arguments
- **Throw `ArgumentException`** for invalid argument values
- **Throw `InvalidOperationException`** for invalid state
- **Include parameter name** in exception messages
- **Use guard clauses** for early returns in validation

---

## Arch ECS Best Practices

### Components
- **Components are value types** (`struct`) - store data, not behavior
- **Keep components small and focused** - each component represents a single aspect
- **Naming**: End component names with `Component` suffix (e.g., `PositionComponent`)
- **Location**: `ECS/Components/` directory, namespace `MonoBall.Core.ECS.Components`
- **Keep components pure data** - no methods, only properties

### Systems
- **Inherit from `BaseSystem<World, float>`** (World parameter, float deltaTime)
- **Systems contain logic**, not data - they operate on components
- **Cache QueryDescription**: Store as instance fields (created in constructor) or static readonly fields
- **NEVER create QueryDescription in Update/Render methods** - always cache them
- **Naming**: End system names with `System` suffix (e.g., `MapLoaderSystem`)
- **Location**: `ECS/Systems/` directory, namespace `MonoBall.Core.ECS.Systems`
- **Inject dependencies** through constructor (World, services, managers)
- **Separate concerns**: Keep update logic separate from render logic

### System Organization
- **Use `Group<T>`** to organize related systems (e.g., "MapSystems", "RenderSystems")
- **Call lifecycle methods**: `BeforeUpdate()`, `Update()`, `AfterUpdate()` in that order
- **Update systems in `Game.Update()`**: Pass deltaTime as `(float)gameTime.ElapsedGameTime.TotalSeconds`
- **Render systems separately**: Call render methods from `Game.Draw()`, not through Group

### System Disposal (IDisposable)
- **Implement `IDisposable`** only when system has managed resources (event subscriptions, cached collections)
- **Event subscriptions require disposal**: If subscribing to events, MUST implement `IDisposable` and unsubscribe in `Dispose()`
- **Use standard dispose pattern** with protected `Dispose(bool disposing)` method
- **Use `new` keyword** on public `Dispose()` if `BaseSystem` has a `Dispose()` method
- **Do NOT call `GC.SuppressFinalize(this)`** unless you have a finalizer (systems typically don't)
- **Always check `_disposed` flag** to prevent multiple disposals

#### Dispose Pattern Template
```csharp
public class MySystem : BaseSystem<World, float>, IDisposable
{
    private bool _disposed = false;

    public MySystem(World world) : base(world)
    {
        EventBus.Subscribe<SomeEvent>(OnSomeEvent);
    }

    public new void Dispose() => Dispose(true);

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed && disposing)
        {
            EventBus.Unsubscribe<SomeEvent>(OnSomeEvent);
            // Clear cached collections, dispose other resources
        }
        _disposed = true;
    }
}
```

### Query Performance
- **Cache QueryDescription**: Create in constructor, store as instance field or static readonly
- **Use appropriate filters**: `WithAll` for AND, `WithAny` for OR, `WithNone` for exclusion
- **Single-pass queries**: Get all needed components in one query pass
- **Avoid allocations** in hot path queries - reuse collections or use stack allocation

### Entity Management
- **Create entities** with `World.Create()` and pass initial components
- **Destroy entities** with `World.Destroy()` when no longer needed
- **Avoid storing Entity references** long-term - use component data instead

### Example: Component
```csharp
namespace MonoBall.Core.ECS.Components
{
    /// <summary>
    /// Component that stores world position for entities.
    /// </summary>
    public struct PositionComponent
    {
        /// <summary>
        /// The world position in pixels.
        /// </summary>
        public Vector2 Position { get; set; }
    }
}
```

### Example: System with Manual Query
```csharp
public class MapRendererSystem : BaseSystem<World, float>
{
    private readonly GraphicsDevice _graphicsDevice;
    private readonly QueryDescription _queryDescription;
    
    public MapRendererSystem(World world, GraphicsDevice graphicsDevice) : base(world)
    {
        _graphicsDevice = graphicsDevice ?? throw new ArgumentNullException(nameof(graphicsDevice));
        _queryDescription = new QueryDescription()
            .WithAll<TileChunkComponent, PositionComponent, RenderableComponent>();
    }
    
    public override void Update(in float deltaTime)
    {
        World.Query(in _queryDescription, (ref TileChunkComponent chunk, ref PositionComponent pos, ref RenderableComponent render) =>
        {
            if (render.IsVisible)
            {
                // Update logic
            }
        });
    }
}
```

---

## Event System Best Practices

### Event Architecture
- **Use Arch.EventBus** for decoupled event communication
- **Events are value types** (`struct`) - lightweight data containers
- **Naming**: End event names with `Event` suffix (e.g., `MapLoadedEvent`)
- **Location**: `ECS/Events/` directory, namespace `MonoBall.Core.ECS.Events`
- **Events carry context**: Include relevant entity references, IDs, and state data

### Event Design & Publishing
- **Keep events focused** - represent a single occurrence or state change
- **Make events immutable** - use `readonly` properties or init-only setters
- **Document events** with XML comments explaining when they're fired
- **Use EventBus.Send()** to broadcast events (takes ref parameter for struct events)
- **Fire events after state changes** are complete and valid

### Event Subscription
- **Subscribe to events** in systems that need to react to state changes
- **Use EventBus.Subscribe()** for subscription
- **MUST unsubscribe** when systems are disposed to prevent memory leaks
- **Keep event handlers focused** - delegate to other methods if logic is complex

### Example: Event Definition
```csharp
namespace MonoBall.Core.ECS.Events
{
    /// <summary>
    /// Event fired when a map is loaded.
    /// </summary>
    public struct MapLoadedEvent
    {
        public string MapId { get; set; }
        public Entity MapEntity { get; set; }
    }
}
```

### Example: Publishing & Subscribing
```csharp
// Publishing
var loadedEvent = new MapLoadedEvent { MapId = mapId, MapEntity = mapEntity };
EventBus.Send(ref loadedEvent);

// Subscribing (in system constructor)
EventBus.Subscribe<MapTransitionEvent>(OnMapTransition);

// Unsubscribing (in Dispose)
EventBus.Unsubscribe<MapTransitionEvent>(OnMapTransition);
```

---

## Mod System Guidelines

- **Validate mods before loading** using `ModValidator`
- **Handle loading errors gracefully** - log errors but don't crash
- **Use strongly-typed definitions** with generics (`GetDefinition<T>()`)
- **Store definitions in registry** for efficient lookup

---

## Anti-Patterns to Avoid

### General
- ❌ **God classes** - classes that do too much
- ❌ **Magic numbers and strings** - use constants or configuration
- ❌ **Unchecked null references** - use nullable types properly
- ❌ **Heavy computation in Draw()** - pre-calculate or cache
- ❌ **Creating objects in Update/Draw loops** - reuse or pool
- ❌ **Ignoring GameTime** - don't assume fixed frame rate
- ❌ **Tight coupling** - use interfaces and dependency injection
- ❌ **Copy-paste code** - extract to shared methods/classes
- ❌ **Maintaining backward compatibility** - refactor freely, update all call sites
- ❌ **Fallback code** - fail fast with clear exceptions

### ECS-Specific
- ❌ **Storing behavior in components** - components are data only
- ❌ **Large components** - split into focused, cohesive components
- ❌ **Direct system-to-system calls** - use events for communication
- ❌ **Storing Entity references in components** - use IDs or component relationships
- ❌ **Creating QueryDescription in hot paths** - always cache them
- ❌ **Double querying** - get all needed components in one pass
- ❌ **Allocations in queries** - reuse collections or use stack allocation
- ❌ **Mixing update and render logic** - separate into different systems/methods
- ❌ **Not disposing event subscriptions** - unsubscribe in Dispose() to prevent leaks

### Event-Specific
- ❌ **Events with side effects** - events carry data, not behavior
- ❌ **Circular event dependencies** - avoid events triggering events that trigger the first
- ❌ **Events for every state change** - only fire for significant, observable changes

---

## Code Examples

### Good: Dependency Injection
```csharp
public class ModLoader
{
    private readonly string _modsDirectory;
    private readonly DefinitionRegistry _registry;
    
    public ModLoader(string modsDirectory, DefinitionRegistry registry)
    {
        _modsDirectory = modsDirectory ?? throw new ArgumentNullException(nameof(modsDirectory));
        _registry = registry ?? throw new ArgumentNullException(nameof(registry));
    }
}
```

### Good: Exception Handling
```csharp
public void Register(DefinitionMetadata metadata)
{
    if (_isLocked)
    {
        throw new InvalidOperationException("DefinitionRegistry is locked and cannot be modified.");
    }
    
    if (string.IsNullOrEmpty(metadata.Id))
    {
        throw new ArgumentException("Definition ID cannot be null or empty.", nameof(metadata));
    }
    
    // Registration logic
}
```
